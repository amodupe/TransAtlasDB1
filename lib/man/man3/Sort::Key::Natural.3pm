.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sort::Key::Natural 3"
.TH Sort::Key::Natural 3 "2014-04-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sort::Key::Natural \- fast natural sorting
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Sort::Key::Natural qw(natsort);
\&
\&    my @data = qw(foo1 foo23 foo6 bar12 bar1
\&                  foo bar2 bar\-45 foomatic b\-a\-r\-45);
\&
\&    my @sorted = natsort @data;
\&
\&    print "@sorted\en";
\&    # prints:
\&    #   b\-a\-r\-45 bar1 bar2 bar12 bar\-45 foo foo1 foo6 foo23 foomatic
\&
\&    use Sort::Key::Natural qw(natkeysort);
\&
\&    my @objects = (...);
\&    my @sorted = natkeysort { $_\->get_id } @objects;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends the Sort::Key family of modules to support
natural sorting.
.PP
Under natural sorting, strings are split at word and number
boundaries, and the resulting substrings are compared as follows:
.IP "\(bu" 4
numeric substrings are compared numerically
.IP "\(bu" 4
alphabetic substrings are compared lexically
.IP "\(bu" 4
numeric substrings come always before alphabetic substrings
.PP
Spaces, symbols and non-printable characters are only considered for
splitting the string into its parts but not for sorting. For instance
\&\f(CW\*(C`foo\-bar\-42\*(C'\fR is broken in three substrings \f(CW\*(C`foo\*(C'\fR, \f(CW\*(C`bar\*(C'\fR and \f(CW42\fR
and after that the dashes are ignored.
.PP
Note, that the sorting is case sensitive. To do a case insensitive
sort you have to convert the keys explicitly:
.PP
.Vb 1
\&  my @sorted = natkeysort { lc $_ } @data
.Ve
.PP
Also, once this module is loaded, the new type \f(CW\*(C`natural\*(C'\fR (or \f(CW\*(C`nat\*(C'\fR) will
be available from Sort::Key::Maker. For instance:
.PP
.Vb 2
\&  use Sort::Key::Natural;
\&  use Sort::Key::Maker i_rnat_keysort => qw(integer \-natural);
.Ve
.PP
creates a multi-key sorter \f(CW\*(C`i_rnat_keysort\*(C'\fR accepting two keys, the
first to be compared as an integer and the second in natural
descending order.
.PP
There is also an alternative set of natural sorting functions that
recognize floating point numbers. They use the key type \f(CW\*(C`natwf\*(C'\fR
(abbreviation of \f(CW\*(C`natural_with_floats\*(C'\fR).
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
the functions that can be imported from this module are:
.ie n .IP "natsort @data" 4
.el .IP "natsort \f(CW@data\fR" 4
.IX Item "natsort @data"
returns the elements of \f(CW@data\fR sorted in natural order.
.ie n .IP "rnatsort @data" 4
.el .IP "rnatsort \f(CW@data\fR" 4
.IX Item "rnatsort @data"
returns the elements of \f(CW@data\fR sorted in natural descending order.
.ie n .IP "natkeysort { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "natkeysort { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "natkeysort { CALC_KEY($_) } @data"
returns the elements on \f(CW@array\fR naturally sorted by the keys
resulting from applying them \f(CW\*(C`CALC_KEY\*(C'\fR.
.ie n .IP "rnatkeysort { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "rnatkeysort { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "rnatkeysort { CALC_KEY($_) } @data"
is similar to \f(CW\*(C`natkeysort\*(C'\fR but sorts the elements in descending
order.
.ie n .IP "natsort_inplace @data" 4
.el .IP "natsort_inplace \f(CW@data\fR" 4
.IX Item "natsort_inplace @data"
.PD 0
.ie n .IP "rnatsort_inplace @data" 4
.el .IP "rnatsort_inplace \f(CW@data\fR" 4
.IX Item "rnatsort_inplace @data"
.ie n .IP "natkeysort_inplace { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "natkeysort_inplace { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "natkeysort_inplace { CALC_KEY($_) } @data"
.ie n .IP "rnatkeysort_inplace { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "rnatkeysort_inplace { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "rnatkeysort_inplace { CALC_KEY($_) } @data"
.PD
these functions are similar respectively to \f(CW\*(C`natsort\*(C'\fR, \f(CW\*(C`rnatsort\*(C'\fR,
\&\f(CW\*(C`natsortkey\*(C'\fR and \f(CW\*(C`rnatsortkey\*(C'\fR, but they sort the array \f(CW@data\fR in
place.
.ie n .IP "$key = mkkey_natural $string" 4
.el .IP "\f(CW$key\fR = mkkey_natural \f(CW$string\fR" 4
.IX Item "$key = mkkey_natural $string"
given \f(CW$string\fR, returns a key that can be compared lexicographically
to another key obtained in the same manner, results in the same order
as comparing the former strings as in the natural order.
.Sp
If the argument \f(CW$key\fR is not provided it defaults to \f(CW$_\fR.
.ie n .IP "natwfsort @data" 4
.el .IP "natwfsort \f(CW@data\fR" 4
.IX Item "natwfsort @data"
.PD 0
.ie n .IP "rnatwfsort @data" 4
.el .IP "rnatwfsort \f(CW@data\fR" 4
.IX Item "rnatwfsort @data"
.ie n .IP "natwfkeysort { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "natwfkeysort { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "natwfkeysort { CALC_KEY($_) } @data"
.ie n .IP "rnatwfkeysort { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "rnatwfkeysort { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "rnatwfkeysort { CALC_KEY($_) } @data"
.ie n .IP "natwfsort_inplace @data" 4
.el .IP "natwfsort_inplace \f(CW@data\fR" 4
.IX Item "natwfsort_inplace @data"
.ie n .IP "rnatwfsort_inplace @data" 4
.el .IP "rnatwfsort_inplace \f(CW@data\fR" 4
.IX Item "rnatwfsort_inplace @data"
.ie n .IP "natwfkeysort_inplace { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "natwfkeysort_inplace { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "natwfkeysort_inplace { CALC_KEY($_) } @data"
.ie n .IP "rnatwfkeysort_inplace { \s-1CALC_KEY\s0($_) } @data" 4
.el .IP "rnatwfkeysort_inplace { \s-1CALC_KEY\s0($_) } \f(CW@data\fR" 4
.IX Item "rnatwfkeysort_inplace { CALC_KEY($_) } @data"
.ie n .IP "mkkey_natural_with_floats $key" 4
.el .IP "mkkey_natural_with_floats \f(CW$key\fR" 4
.IX Item "mkkey_natural_with_floats $key"
.PD
this ugly named set of functions perform in the same way as its
s/natwf/nat/ counterpart with the difference that they honor floating
point numbers embedded inside the strings.
.Sp
In this context a floating point number is a string matching the
regular expression \f(CW\*(C`/[+\e\-]?\ed+(\e.\ed*)?/\*(C'\fR. Note that numbers with an
exponent part (i.e. \f(CW\*(C`1.12E\-12\*(C'\fR) are not recognized as such.
.Sp
Note also that numbers without an integer part (i.e. \f(CW.2\fR or \f(CW\*(C`\-.12\*(C'\fR)
are not supported either.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sort::Key, Sort::Key::Maker.
.PP
Other module providing similar functionality is Sort::Naturally.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006, 2012, 2014 by Salvador Fandin\*~o,
<sfandino@yahoo.com>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
