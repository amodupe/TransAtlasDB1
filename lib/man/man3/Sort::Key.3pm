.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sort::Key 3"
.TH Sort::Key 3 "2014-04-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sort::Key \- the fastest way to sort anything in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Sort::Key qw(keysort nkeysort ikeysort);
\&
\&  @by_name = keysort { "$_\->{surname} $_\->{name}" } @people;
\&
\&  # sorting by a numeric key:
\&  @by_age = nkeysort { $_\->{age} } @people;
\&
\&  # sorting by a numeric integer key:
\&  @by_sons = ikeysort { $_\->{sons} } @people;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sort::Key provides a set of functions to sort lists of values by some
calculated key value.
.PP
It is faster (usually \fBmuch faster\fR) and uses less memory than other
alternatives implemented around perl sort function (\s-1ST, GRT,\s0 etc.).
.PP
Multi-key sorting functionality is also provided via the companion
modules Sort::Key::Multi, Sort::Key::Maker and
Sort::Key::Register.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
This module provides a large number of sorting subroutines but
they are all variations off the \f(CW\*(C`keysort\*(C'\fR one:
.PP
.Vb 1
\&  @sorted = keysort { CALC_KEY($_) } @data
.Ve
.PP
that is conceptually equivalent to
.PP
.Vb 1
\&  @sorted = sort { CALC_KEY($a) cmp CALC_KEY($b) } @data
.Ve
.PP
and where \f(CW\*(C`CALC_KEY($_)\*(C'\fR can be any expression to extract the key
value from \f(CW$_\fR (not only a subroutine call).
.PP
For instance, some variations are \f(CW\*(C`nkeysort\*(C'\fR that performs a numeric
comparison, \f(CW\*(C`rkeysort\*(C'\fR that orders the data in descending order,
\&\f(CW\*(C`ikeysort\*(C'\fR and \f(CW\*(C`ukeysort\*(C'\fR that are optimized versions of \f(CW\*(C`nkeysort\*(C'\fR
that can be used when the keys are integers or unsigned integers
respectively, etc.
.PP
Also, inplace versions of the sorters are provided. For instance
.PP
.Vb 1
\&  keysort_inplace { CALC_KEY($_) } @data
.Ve
.PP
that is equivalent to
.PP
.Vb 1
\&  @data = keysort { CALC_KEY($_) } @data
.Ve
.PP
but being (a bit) faster and using less memory.
.PP
The full list of subroutines that can be imported from this module
follows:
.ie n .IP "keysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "keysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "keysort { CALC_KEY } @array"
returns the elements on \f(CW@array\fR sorted by the key calculated
applying \f(CW\*(C`{ CALC_KEY }\*(C'\fR to them.
.Sp
Inside \f(CW\*(C`{ CALC_KEY }\*(C'\fR, the object is available as \f(CW$_\fR.
.Sp
For example:
.Sp
.Vb 2
\&  @a=({name=>john, surname=>smith}, {name=>paul, surname=>belvedere});
\&  @by_name=keysort {$_\->{name}} @a;
.Ve
.Sp
This function honours the \f(CW\*(C`use locale\*(C'\fR pragma.
.ie n .IP "nkeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "nkeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "nkeysort { CALC_KEY } @array"
similar to \f(CW\*(C`keysort\*(C'\fR but compares the keys numerically instead of as
strings.
.Sp
This function honours the \f(CW\*(C`use integer\*(C'\fR pragma, i.e.:
.Sp
.Vb 4
\&  use integer;
\&  my @s=(2.4, 2.0, 1.6, 1.2, 0.8);
\&  my @ns = nkeysort { $_ } @s;
\&  print "@ns\en"
.Ve
.Sp
prints
.Sp
.Vb 1
\&  0.8 1.6 1.2 2.4 2
.Ve
.ie n .IP "rnkeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "rnkeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rnkeysort { CALC_KEY } @array"
works as \f(CW\*(C`nkeysort\*(C'\fR, comparing keys in reverse (or descending) numerical order.
.ie n .IP "ikeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "ikeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "ikeysort { CALC_KEY } @array"
works as \f(CW\*(C`keysort\*(C'\fR but compares the keys as integers (32 bits or more,
no checking is performed for overflows).
.ie n .IP "rikeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "rikeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rikeysort { CALC_KEY } @array"
works as \f(CW\*(C`ikeysort\*(C'\fR, but in reverse (or descending) order.
.ie n .IP "ukeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "ukeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "ukeysort { CALC_KEY } @array"
works as \f(CW\*(C`keysort\*(C'\fR but compares the keys as unsigned integers (32 bits
or more).
.Sp
For instance, it can be used to efficiently sort \s-1IP4\s0 addresses:
.Sp
.Vb 2
\&  my @data = qw(1.2.3.4 4.3.2.1 11.1.111.1 222.12.1.34
\&                0.0.0.0 255.255.255.0) 127.0.0.1);
\&
\&  my @sorted = ukeysort {
\&                   my @a = split /\e./;
\&                   (((($a[0] << 8) + $a[1] << 8) + $a[2] << 8) + $a[3])
\&               } @data;
.Ve
.ie n .IP "rukeysort { \s-1CALC_KEY \s0} @array" 4
.el .IP "rukeysort { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rukeysort { CALC_KEY } @array"
works as \f(CW\*(C`ukeysort\*(C'\fR, but in reverse (or descending) order.
.ie n .IP "keysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "keysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "keysort_inplace { CALC_KEY } @array"
.PD 0
.ie n .IP "nkeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "nkeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "nkeysort_inplace { CALC_KEY } @array"
.ie n .IP "ikeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "ikeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "ikeysort_inplace { CALC_KEY } @array"
.ie n .IP "ukeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "ukeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "ukeysort_inplace { CALC_KEY } @array"
.ie n .IP "rkeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "rkeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rkeysort_inplace { CALC_KEY } @array"
.ie n .IP "rnkeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "rnkeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rnkeysort_inplace { CALC_KEY } @array"
.ie n .IP "rikeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "rikeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rikeysort_inplace { CALC_KEY } @array"
.ie n .IP "rukeysort_inplace { \s-1CALC_KEY \s0} @array" 4
.el .IP "rukeysort_inplace { \s-1CALC_KEY \s0} \f(CW@array\fR" 4
.IX Item "rukeysort_inplace { CALC_KEY } @array"
.PD
work as the corresponding \f(CW\*(C`keysort\*(C'\fR functions but sorting the array
inplace.
.ie n .IP "rsort @array" 4
.el .IP "rsort \f(CW@array\fR" 4
.IX Item "rsort @array"
.PD 0
.ie n .IP "nsort @array" 4
.el .IP "nsort \f(CW@array\fR" 4
.IX Item "nsort @array"
.ie n .IP "rnsort @array" 4
.el .IP "rnsort \f(CW@array\fR" 4
.IX Item "rnsort @array"
.ie n .IP "isort @array" 4
.el .IP "isort \f(CW@array\fR" 4
.IX Item "isort @array"
.ie n .IP "risort @array" 4
.el .IP "risort \f(CW@array\fR" 4
.IX Item "risort @array"
.ie n .IP "usort @array" 4
.el .IP "usort \f(CW@array\fR" 4
.IX Item "usort @array"
.ie n .IP "rusort @array" 4
.el .IP "rusort \f(CW@array\fR" 4
.IX Item "rusort @array"
.ie n .IP "rsort_inplace @array" 4
.el .IP "rsort_inplace \f(CW@array\fR" 4
.IX Item "rsort_inplace @array"
.ie n .IP "nsort_inplace @array" 4
.el .IP "nsort_inplace \f(CW@array\fR" 4
.IX Item "nsort_inplace @array"
.ie n .IP "rnsort_inplace @array" 4
.el .IP "rnsort_inplace \f(CW@array\fR" 4
.IX Item "rnsort_inplace @array"
.ie n .IP "isort_inplace @array" 4
.el .IP "isort_inplace \f(CW@array\fR" 4
.IX Item "isort_inplace @array"
.ie n .IP "risort_inplace @array" 4
.el .IP "risort_inplace \f(CW@array\fR" 4
.IX Item "risort_inplace @array"
.ie n .IP "usort_inplace @array" 4
.el .IP "usort_inplace \f(CW@array\fR" 4
.IX Item "usort_inplace @array"
.ie n .IP "rusort_inplace @array" 4
.el .IP "rusort_inplace \f(CW@array\fR" 4
.IX Item "rusort_inplace @array"
.PD
are simplified versions of its \f(CW\*(C`keysort\*(C'\fR cousins. They use the own
values as the sorting keys.
.Sp
For instance those constructions are equivalent:
.Sp
.Vb 1
\&  @sorted = nsort @foo;
\&
\&  @sorted = nkeysort { $_ } @foo;
\&
\&  @sorted = sort { $a <=> $b } @foo;
.Ve
.IP "multikeysorter(@types)" 4
.IX Item "multikeysorter(@types)"
.PD 0
.IP "multikeysorter_inplace(@types)" 4
.IX Item "multikeysorter_inplace(@types)"
.ie n .IP "multikeysorter(\e&genkeys, @types)" 4
.el .IP "multikeysorter(\e&genkeys, \f(CW@types\fR)" 4
.IX Item "multikeysorter(&genkeys, @types)"
.ie n .IP "multikeysorter_inplace(\e&genkeys, @types)" 4
.el .IP "multikeysorter_inplace(\e&genkeys, \f(CW@types\fR)" 4
.IX Item "multikeysorter_inplace(&genkeys, @types)"
.PD
are the low level interface to the multi-key sorting functionality
(normally, you should use Sort::Key::Maker and
Sort::Key::Register or Sort::Key::Multi instead).
.Sp
They get a list of keys descriptions and return a reference to a
multi-key sorting subroutine.
.Sp
Types accepted by default are:
.Sp
.Vb 2
\&  string, str, locale, loc, integer, int,
\&  unsigned_integer, uint, number, num
.Ve
.Sp
and support for additional types can be added via the register_type
subroutine available from Sort::Key::Types or the more
friendly interface available from Sort::Key::Register.
.Sp
Types can be preceded by a minus sign to indicate descending order.
.Sp
If the first argument is a reference to a subroutine it is used as the
multi-key extraction function. If not, the generated sorters
expect one as their first argument.
.Sp
Example:
.Sp
.Vb 2
\&  my $sorter1 = multikeysorter(sub {length $_, $_}, qw(int str));
\&  my @sorted1 = &$sorter1(qw(foo fo o of oof));
\&
\&  my $sorter2 = multikeysorter(qw(int str));
\&  my @sorted2 = &$sorter2(sub {length $_, $_}, qw(foo fo o of oof));
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl sort function, integer, locale.
.PP
Companion modules Sort::Key::Multi, Sort::Key::Register,
Sort::Key::Maker and Sort::Key::Natural.
.PP
Sort::Key::IPv4, Sort::Key::DateTime and Sort::Key::OID
modules add support for additional datatypes to Sort::Key.
.PP
Sort::Key::External allows to sort huge lists that do not fit in
the available memory.
.PP
Other interesting Perl sorting modules are Sort::Maker,
Sort::Naturally and Sort::External.
.SH "SUPPORT"
.IX Header "SUPPORT"
To report bugs, send me and email or use the \s-1CPAN\s0 bug tracking system
at <http://rt.cpan.org>.
.SS "Commercial support"
.IX Subsection "Commercial support"
Commercial support, professional services and custom software
development around this module are available through my current
company. Drop me an email with a rough description of your
requirements and we will get back to you \s-1ASAP.\s0
.SS "My wishlist"
.IX Subsection "My wishlist"
If you like this module and you're feeling generous, take a look at my
Amazon Wish List: <http://amzn.com/w/1WU1P6IR5QZ42>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2007, 2012, 2014 by Salvador Fandin\*~o,
<sfandino@yahoo.com>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
