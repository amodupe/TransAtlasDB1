.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TabularDisplay 3"
.TH TabularDisplay 3 "2014-07-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::TabularDisplay \- Display text in formatted table output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Text::TabularDisplay;
\&
\&    my $table = Text::TabularDisplay\->new(@columns);
\&    $table\->add(@row)
\&        while (@row = $sth\->fetchrow);
\&    print $table\->render;
\&
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | id | name         |
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | 1  | Tom          |
\&    | 2  | Dick         |
\&    | 3  | Barry        |
\&    |    |  (aka Bazza) |
\&    | 4  | Harry        |
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::TabularDisplay simplifies displaying textual data in a table.
The output is identical to the columnar display of query results in
the mysql text monitor.  For example, this data:
.PP
.Vb 3
\&    1, "Tom Jones", "(666) 555\-1212"
\&    2, "Barnaby Jones", "(666) 555\-1213"
\&    3, "Bridget Jones", "(666) 555\-1214"
.Ve
.PP
Used like so:
.PP
.Vb 5
\&    my $t = Text::TabularDisplay\->new(qw(id name phone));
\&    $t\->add(1, "Tom Jones", "(666) 555\-1212");
\&    $t\->add(2, "Barnaby Jones", "(666) 555\-1213");
\&    $t\->add(3, "Bridget Jones", "(666) 555\-1214");
\&    print $t\->render;
.Ve
.PP
Produces:
.PP
.Vb 7
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | id | name          | phone          |
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | 1  | Tom Jones     | (666) 555\-1212 |
\&    | 2  | Barnaby Jones | (666) 555\-1213 |
\&    | 3  | Bridget Jones | (666) 555\-1214 |
\&    +\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.SH "METHODS"
.IX Header "METHODS"
Text::TabularDisplay has four primary methods: \fInew()\fR, \fIcolumns()\fR,
\&\fIadd()\fR, and \fIrender()\fR.  \fInew()\fR creates a new Text::TabularDisplay
instance; \fIcolumns()\fR sets the column headers in the output table;
\&\fIadd()\fR adds data to the instance; and \fIrender()\fR returns a formatted
string representation of the instance.
.PP
There are also a few auxiliary convenience methods: \fIclone()\fR, \fIitems()\fR,
\&\fIreset()\fR, \fIpopulate()\fR, and \fIpaginate()\fR.
.IP "\fBnew\fR" 4
.IX Item "new"
A Text::TabularDisplay instance can be created with column names
passed as constructor args, so these two calls produce similar
objects:
.Sp
.Vb 2
\&    my $t1 = Text::TabularDisplay\->new;
\&    $t1\->columns(qw< one two >);
\&
\&    my $t2 = Text::TabularDisplay\->new(qw< one two >);
.Ve
.Sp
Calling \fInew()\fR on a Text::TabularDisplay instance returns a clone of
the object.  See \*(L"clone\*(R" in Text::TabularDisplay.
.IP "\fBcolumns\fR" 4
.IX Item "columns"
Gets or sets the column names for an instance.  This method is called
automatically by the constructor with any parameters that are passed
to the constructor (if any are passed).
.Sp
When called in scalar context, \fIcolumns()\fR returns the \fInumber of
columns in the instance\fR, rather than the columns themselves.  In list
context, copies of the columns names are returned; the names of the
columns cannot be modified this way.
.IP "\fBadd\fR" 4
.IX Item "add"
Takes a list of items and appends it to the list of items to be
displayed.  \fIadd()\fR can also take a reference to an array, so that large
arrays don't need to be copied.
.Sp
As elements are processed, \fIadd()\fR maintains the width of each column
so that the resulting table has the correct dimensions.
.Sp
\&\fIadd()\fR returns \f(CW$self\fR, so that calls to \fIadd()\fR can be chained:
.Sp
.Vb 1
\&    $t\->add(@one)\->add(@two)\->add(@three);
.Ve
.IP "\fBrender\fR" 4
.IX Item "render"
\&\fIrender()\fR does most of the actual work. It returns a string containing
the data added via \fIadd()\fR, formatted as a table, with a header
containing the column names.
.Sp
\&\fIrender()\fR does not change the state of the object; it can be called
multiple times, with identical output (including identical running
time: the output of render is not cached).
.Sp
If there are no columns defined, then the output table does not
contains a row of column names.  Compare these two sequences:
.Sp
.Vb 4
\&    my $t = Text::TabularDisplay\->new;
\&    $t\->add(qw< 1 2 3 4 >);
\&    $t\->add(qw< 5 6 7 8 >);
\&    print $t\->render;
\&
\&    $t\->columns(qw< one two three four >);
\&    print $t\->render;
\&
\&    # Example 1 output
\&    +\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&    | 1 | 2 | 3 | 4 |
\&    | 5 | 6 | 7 | 8 |
\&    +\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&
\&    # Example 2 output
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    | one | two | three | four |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    | 1   | 2   | 3     | 4    |
\&    | 5   | 6   | 7     | 8    |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.Sp
\&\fIrender()\fR takes optional \f(CW$start\fR and \f(CW$end\fR arguments; these indicate the
start and end \fIindexes\fR for the data to be rendered.  This can be
used for paging and the like:
.Sp
.Vb 3
\&    $t\->add(1, 2, 3)\->add(4, 5, 6)\->add(7, 8, 9)\->add(10, 11, 12);
\&    print $t\->render(0, 1), "\en";
\&    print $t\->render(2, 3), "\en";
.Ve
.Sp
Produces:
.Sp
.Vb 6
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&    | First | Second | Third |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&    | 1     | 2      | 3     |
\&    | 4     | 5      | 6     |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&    | First | Second | Third |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&    | 7     | 8      | 9     |
\&    | 10    | 11     | 12    |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
.Ve
.Sp
As an aside, note the chaining of calls to \fIadd()\fR.
.Sp
The elements in the table are padded such that there is the same
number of items in each row, including the header.  Thus:
.Sp
.Vb 2
\&    $t\->columns(qw< One Two >);
\&    print $t\->render;
\&
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+
\&    | One | Two |    |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+
\&    | 1   | 2   | 3  |
\&    | 4   | 5   | 6  |
\&    | 7   | 8   | 9  |
\&    | 10  | 11  | 12 |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+
.Ve
.Sp
And:
.Sp
.Vb 2
\&    $t\->columns(qw< One Two Three Four>);
\&    print $t\->render;
\&
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    | One | Two | Three | Four |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    | 1   | 2   | 3     |      |
\&    | 4   | 5   | 6     |      |
\&    | 7   | 8   | 9     |      |
\&    | 10  | 11  | 12    |      |
\&    +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.IP "\fIclone()\fR" 4
.IX Item "clone()"
The \fIclone()\fR method returns an identical copy of a Text::TabularDisplay
instance, completely separate from the cloned instance.
.IP "\fIitems()\fR" 4
.IX Item "items()"
The \fIitems()\fR method returns the number of elements currently stored in
the data structure:
.Sp
.Vb 1
\&    printf "There are %d elements in \e$t.\en", $t\->items;
.Ve
.IP "\fIreset()\fR" 4
.IX Item "reset()"
Reset deletes the data from the instance, including columns.  If
passed arguments, it passes them to \fIcolumns()\fR, just like \fInew()\fR.
.IP "\fIpopulate()\fR" 4
.IX Item "populate()"
\&\fIpopulate()\fR as a special case of \fIadd()\fR; \fIpopulate()\fR expects a reference
to an array of references to arrays, such as returned by \s-1DBI\s0's
selectall_arrayref method:
.Sp
.Vb 3
\&    $sql = "SELECT " . join(", ", @c) . " FROM mytable";
\&    $t\->columns(@c);
\&    $t\->populate($dbh\->selectall_arrayref($sql));
.Ve
.Sp
This is for convenience only; the implementation maps this to multiple
calls to \fIadd()\fR.
.SH "NOTES / ISSUES"
.IX Header "NOTES / ISSUES"
Text::TabularDisplay assumes it is handling strings, and does stringy
things with the data, like \fIlength()\fR and \fIsprintf()\fR.  Non-character data
can be passed in, of course, but will be treated as strings; this may
have ramifications for objects that implement overloading.
.PP
The biggest issue, though, is that this module duplicates a some of the
functionality of Data::ShowTable.  Of course, Data::ShowTable is a
large, complex monolithic tool that does a lot of things, while
Text::TabularDisplay is small and fast.
.SH "AUTHOR"
.IX Header "AUTHOR"
darren chamberlain <darren@cpan.org>
.SH "CREDITS"
.IX Header "CREDITS"
The following people have contributed patches, suggestions, tests,
feedback, or good karma:
.PP
.Vb 10
\&    David N. Blank\-Edelman
\&    Eric Cholet
\&    Ken Youens\-Clark
\&    Michael Fowler
\&    Paul Cameron
\&    Prakash Kailasa
\&    Slaven Rezic
\&    Harlan Lieberman\-Berg
\&    Patrick Kuijvenhoven
\&    Miko O\*(AqSullivan
.Ve
.SH "VERSION"
.IX Header "VERSION"
This documentation describes \f(CW\*(C`Text::TabularDisplay\*(C'\fR version 1.38.
